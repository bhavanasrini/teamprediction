from __future__ import division
from bs4 import BeautifulSoup
import requests
import functools
import csv

# LISTS FOR PROGRAM
players = []
stats =[]
pOfXsWins = []
pOfXsLosses = []
probs_win = []
probs_lose = []
first_down_prob = []
passing_prob = []
rushing_gain_prob = []
turnover_prob = []
passing_gain_prob = []
outcome = []

# GRAB STATS FOR TEAM ONE AND TEAM TWO
def grabstats(game):
    # PICK THE WEBSITE
    # Bills vs Jets
    #html = requests.get("http://www.espn.com/nfl/matchup?gameId=400791486").text
    # Cowboys vs Broncos
    #html = requests.get("http://www.espn.com/nfl/matchup?gameId=400951673").text
    # Packers vs. Broncos
    html = requests.get(game).text
    #html = requests.get("http://www.espn.com/nfl/matchup?gameId=400791684").text
    soup = BeautifulSoup(html, 'html5lib')

    # GRAB ALL STAT INFO
    for td_tag in soup.find_all('td'):
        stat = td_tag.text
        stats.append(stat)

# NAME OF EACH TEAM
def team1():
    return stats[0]
def team2():
    return stats[6]

# POINTS SCORED IN EACH QUARTER
def t1_points_q1():
    return float(stats[1])
def t1_points_q2():
    return float(stats[2])
def t1_points_q3():
    return float(stats[3])
def t1_points_q4():
    return float(stats[4])
def t1_points_total():
    return float(stats[5])
def t2_points_q1():
    return float(stats[7])
def t2_points_q2():
    return float(stats[8])
def t2_points_q3():
    return float(stats[9])
def t2_points_q4():
    return float(stats[10])
def t2_points_total():
    return float(stats[11])

# NUMBER OF FIRST DOWNS
def t1_first_downs():
    return float(stats[13])
def t2_first_downs():
    return float(stats[14])

# PASSING FIRST DOWNS
def t1_passing_first_downs():
    return float(stats[16])
def t2_passing_first_downs():
    return float(stats[17])

# RUSHING FIRST DOWNS
def t1_rushing_first_downs():
    return float(stats[19])
def t2_rushing_first_downs():
    return float(stats[20])
def t1_first_downs_from_penalties():
    return float(stats[22])
def t2_first_downs_from_penalties():
    return float(stats[24])

# NEED TO CHANGE ALL THE EFFICIENCIES
def t1_third_down_efficiency():
    answer = stats[25].replace('-', ' ')
    for item in answer:
        x = item[0]
        y = item[2:]
        print(x, y)
    # NEED TO DO THE CALCULATE WHEN MAKING THIS CALL
def t2_third_down_efficiency():
    # NEED TO FIX THIS ONE TWO, CAUSE THERE ARE TWO ANSWERS
    return stats[26]
def t1_fourth_down_efficiency():
    return
def t2_fourth_down_efficiency():
    return

# TOTAL PLAYS/YARDS
def t1_total_plays():
    return float(stats[31])
def t2_total_plays():
    return float(stats[32])
def t1_total_yards():
    return float(stats[34])
def t2_total_yards():
    return float(stats[35])
def t1_total_drives():
    return float(stats[37])
def t2_total_drives():
    return float(stats[38])
def t1_yards_per_play():
    return float(stats[40])
def t2_yards_per_play():
    return float(stats[41])
def t1_passing():
    return float(stats[43])
def t2_passing():
    return float(stats[44])

# NEED TO FIX THE FOLLOWING
def t1_pass_comp_att_ratio():
    return float(stats[46])
def t2_pass_comp_att_ratio():
    return float(stats[47])
def t1_intercept():
    return float(stats[52])
def t2_intercept():
    return float(stats[53])
def t1_sacks_and_yards_lost():
    return float(stats[55])
def t2_sacks_and_yards_lost():
    return float(stats[56])

# RUSHING STATS
def t1_rushing():
    return float(stats[58])
def t2_rushing():
    return float(stats[59])
def t1_rushing_attempts():
    return float(stats[61])
def t2_rushing_attempts():
    return float(stats[62])
def t1_yards_per_rush():
    return float(stats[64])
def t2_yards_per_rush():
    return float(stats[65])

# NEED TO FIX
def t1_red_zone_ratio():
    return stats[67]
def t2_red_zone_ratio():
    return stats[68]
def t1_turnovers():
    return float(stats[73])
def t2_turnovers():
    return float(stats[74])
def t1_fumbles_lost():
    return stats[76]
def t2_fumbles_lost():
    return stats[77]

# PROBABILITY OF P(X)
def prob_t1_rushing():
    return t1_rushing_attempts() / t1_total_plays()
def prob_t1_passing():
    # NEED TO RETURN THE SECOND PART OF COMP-ATT IN PASSING / THE # OF TOTAL PLAYS
    return
def t1_prob_of_first_down_from_penalty():
    return t1_first_downs_from_penalties() / t1_first_downs()

# CHANGE THESE TO THE TOTAL PAST GAMES FROM TAB RESULTS TEAM ONCE YOU GET IT WORKING
def prob_of_t1_winning():
    if winning_team() == 1:
        z = 1
    else:
        z = 0
    return (0.5 + z) / 2
def prob_of_t2_winning():
    if winning_team() == 2:
        z = 1
    else:
        z = 0
    return (0.5 + z) / 2
#THIS MAY NEED GAUSSIAN DISTRO BASED OFF OF PAST GAMES * 0.5 PRIOR KNOWLEDGE

# RETURNS WINNING TEAM FOR THAT GAME
def winning_team():
    if t1_points_total() > t2_points_total():
        return 1
    else:
        return 2


# NEED TO CREATE PROBABILITIES OF AN EVENT HAPPENING
def p_first_down_t1():
    z = t1_first_downs()/ t1_total_plays()
    first_down_prob.append(z)
    return z
def p_first_down_t2():
    z = t2_first_downs() / t2_total_plays()
    first_down_prob.append(z)
    return z
def p_t1_rushing_gain():
    z = t1_rushing() / t1_total_yards()
    rushing_gain_prob.append(z)
    return z
def p_t2_rushing_gain():
    z = t2_rushing() / t2_total_yards()
    rushing_gain_prob.append(z)
    return z
def p_t1_passing_gain():
    z = t1_passing() / t1_total_yards()
    passing_gain_prob.append(z)
    return z
def p_t2_passing_gain():
    z = t2_passing() / t2_total_yards()
    passing_gain_prob.append(z)
    return z
def p_t1_interception():
    z = t2_intercept() / t2_total_plays()
    if  z == 0:
        z = 1 / (t2_total_plays() + t1_total_plays())
    return z
def p_t2_interception():
    z = t1_intercept() / t1_total_plays()
    if z == 0:
        z = 1 / (t2_total_plays() + t1_total_plays())
    return z

def p_t1_turnover():
    z = t2_turnovers() / t2_total_plays()
    if z == 0:
        z = 1 / (t2_total_plays() + t1_total_plays())
    turnover_prob.append(z)
    return z
def p_t2_turnover():
    z = t1_turnovers() / t1_total_plays()
    if z == 0:
        z = 1 / (t2_total_plays() + t1_total_plays())
    turnover_prob.append(z)
    return z
def p_passing_yards_from_t1():
    z = t1_passing() / (t1_total_yards() + t2_total_yards())
    passing_prob.append(z)
    return z
def p_passing_yards_from_t2():
    z = t2_passing() / (t1_total_yards() + t2_total_yards())
    passing_prob.append(z)
    return z

# NEED TO CREATE THE LIST OF PROBABILITIES X OCCURS
def build_up_p_x_given_win_list():
    # NEED TO FILL IN THE PROBABILITY OF X OCCURING GIVEN A WIN
    z = prob_of_t1_winning()
    pOfXsWins.append((p_first_down_t1() * z) / z)
    pOfXsWins.append((p_t1_rushing_gain() * z) / z)
    pOfXsWins.append((p_t1_passing_gain() * z) / z)
    pOfXsWins.append((p_t1_turnover() * z))
    pOfXsWins.append((p_passing_yards_from_t1() * z) / z)
    if winning_team() == 1:
        outcome.append(1)
    else:
        outcome.append(0)
    return

def build_up_p_x_given_loss_list():
    # NEED TO FILL IN THE PROBABILITY OF X OCCURING GIVEN A LOSS
    #LIST = (P(X)*P(Y))/P(Y)
    z = prob_of_t2_winning()
    pOfXsLosses.append((p_first_down_t2() * z) / z)
    pOfXsLosses.append((p_t2_rushing_gain() * z) / z)
    pOfXsLosses.append((p_t2_passing_gain() * z) / z)
    pOfXsLosses.append((p_t2_turnover() * z) / z)
    pOfXsLosses.append((p_passing_yards_from_t2() * z) / z)
    if winning_team() == 2:
        outcome.append(1)
    else:
        outcome.append(0)
    return

# FOR EACH X ATTR NEED TO FIND X | Y
def training():
    # LIST * P(Y)
    t1_win = prob_of_t1_winning()
    t1_lose = prob_of_t2_winning()
    for i in pOfXsWins:
        probs_win.append(i * t1_win)
    for i in pOfXsLosses:
        probs_lose.append(i * t1_lose)

#BASED OFF OF INFO FROM TRAINING WHO SHOULD WIN
def classify():
    # argmax Î  of list
    answer = []
    prob_of_win = functools.reduce(lambda x, y: x * y, probs_win) * prob_of_t1_winning()
    prob_of_loss = functools.reduce(lambda x, y: x * y, probs_lose) * prob_of_t2_winning()
    answer.append(prob_of_win)
    answer.append(prob_of_loss)
    max_value = max(answer)
    max_index = answer.index(max_value)
    if max_index == 0:
        print("TEAM 1 is going to win!")
    if max_index == 1:
        print("TEAM 2 is going to win!")

#TO FIND MAX PROBABILITY OF X | Y
def write_CSV():
    with open("data.csv", "w") as e:
        wr = csv.writer(e)
        #F = FIRST DOWN PROB
        #A = passing_prob
        #T = TURNOVER PROB
        #P = PASSING GAIN PROB
        #O = OUTCOME
        wr.writerow("FATPO")
        for i in zip(first_down_prob, passing_prob,
                     turnover_prob,
                     passing_gain_prob, outcome):
            wr.writerow(i)
def append_CSV():
    with open("data.csv", "a") as f:
        wr = csv.writer(f)
        for i in zip(first_down_prob[-2:], passing_prob[-2:], turnover_prob[-2:], passing_gain_prob[-2:], outcome[-2:]):
            wr.writerow(i)
            
def game_1():
    build_up_p_x_given_win_list()
    build_up_p_x_given_loss_list()
    training()
    classify()
    write_CSV()

def game_2():
    build_up_p_x_given_win_list()
    build_up_p_x_given_loss_list()
    training()
    classify()
    append_CSV()

if __name__ == "__main__":
    grabstats(game="http://www.espn.com/nfl/matchup?gameId=400951834")
    stats = [x.replace('\t', '').replace('\n', '') for x in stats]
    game_1()
    print(stats)
    del stats[:]
    grabstats(game="http://www.espn.com/nfl/matchup?gameId=400951673")
    stats = [x.replace('\t', '').replace('\n', '') for x in stats]
    game_2()
    print(stats)
    # NOW NEED TO READ FROM CSV FILE TO CREATE THE CLASSIFIER
